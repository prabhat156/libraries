<!DOCTYPE html>
<meta charset="utf-8">

<link href="../src/nv.d3.css" rel="stylesheet" type="text/css">

<style>

body {
  overflow-y:scroll;
}

text {
  font: 12px sans-serif;
}

svg {
  display: block;
}

#chart1 svg {
  height: 600px;
  min-width: 100px;
  min-height: 100px;
/*
  margin: 50px;
  Minimum height and width is a good idea to prevent negative SVG dimensions...
  For example width should be =< margin.left + margin.right + 1,
  of course 1 pixel for the entire chart would not be very useful, BUT should not have errors
*/
}

</style>
<body>

  <div id="chart" class='with-3d-shadow with-transitions'>
    <svg style="height: 600px;"></svg>
  </div>

<script src="../lib/d3.v3.js"></script>
<script src="../nv.d3.js"></script>
<script src="../src/tooltip.js"></script>
<script src="../src/utils.js"></script>
<script src="../src/models/legend.js"></script>
<script src="../src/models/axis.js"></script>
<script src="../src/models/scatter.js"></script>
<script src="../src/models/line.js"></script>
<script src="../src/models/groupedArea.js"></script>
<script src="../src/models/stackedAreaNew1.js"></script>
<script src="../src/models/SB_timeline_ALL_OP_1_NEWX.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="stream_layers.js"></script>
<script>

    var myBrand = "Cheerios";
    var myBrandEvent = "cheerios";
    //var TS_start = 1390599844;
    //var TS_end = 1390969192;
    var TS_start = (new Date(2014,01,02,16,30,00)).getTime()/1000;
    var TS_end = (new Date(2014,01,02,21,52,00)).getTime()/1000;

    // Variables for different types of data
    var timelineData;
    var cumulativeTimelineData;
    var sentimentData;
    var adEventsData;
    var gameEventsData;
    var eventsData;
    var segmentData;
    var plotData

    var urls = ["http://localhost:5700/twitter/brand_timelines?keyword="+myBrand+"&start="+TS_start+"&end="+TS_end+"&binwidth=120&normalized=local&event="+myBrandEvent+"&period=1",
                "http://localhost:5700/twitter/brand_timelines?keyword="+myBrand+"&start="+TS_start+"&end="+TS_end+"&binwidth=120&normalized=abs&event="+myBrandEvent+"&period=1",
                "http://localhost:5700/twitter/brand_sentiment_timelines?keyword="+myBrand+"&start="+TS_start+"&end="+TS_end+"&binwidth=120"];
    $(document).ready(function(){
        $.ajax({
            url: urls[0],
            dataType: "jsonp",
            success: function(response){
                // Extract the timeline data
                timelineData = Object.keys(response)
                                .filter(function(key){ return key !== 'allevent' && key !== 'period'})
                                .map(function(key, i){
                                    return{
                                        key: key,
                                        timeline: true,
                                        values: response[key].map(function(point){
                                            // Map based on whether events are available or not
                                            if(point.length > 2){
                                                return {
                                                    x: new Date(point[0]*1000),
                                                    y: point[1]*100,
                                                    events: point[2]
                                                }
                                            } else {
                                                return {
                                                    x: new Date(point[0]*1000),
                                                    y: point[1]*100
                                                }
                                            }
                                        })
                                    }
                                });
                // Create the ad events data
                adEventsData = timelineData.map(function(series){
                    return{
                        key: series.key,
                        event: true,
                        values: series.values.filter(function(point){
                            return typeof point.events !== 'undefined';
                        })
                    }
                });
                adEventsData.forEach(function(series){
                    var temp = series.values.map(function(point){
                        return point.events.map(function(ad_event, i){
                            return {
                                x: point.x,
                                y: point.y,
                                label: ad_event,
                                offset: i
                            }
                        });
                    });
                    series.values = d3.merge(temp);
                });

                // Extract the game events data
                gameEventsData = Object.keys(response)
                                    .filter(function(key){ return key === 'allevent'})
                                    .map(function(key){
                                        return{
                                            key: key,
                                            event: true,
                                            disabled: false,
                                            values: response[key].map(function(point){
                                                return {
                                                    x: new Date(point[0]*1000),
                                                    y: -1,
                                                    //events: point[1]
                                                    label: point[1]
                                                }
                                            })
                                        }
                                    });

                //NOT REQUIRED//// Sort the series.values and find unique and/or histogram
                //NOT REQUIRED//gameEventsData.forEach(function(series){
                //NOT REQUIRED//    series.values = series.values.sort(function(a,b){ return a.x > b.x});
                //NOT REQUIRED//});
                //NOT REQUIRED//var unique_values = d3.set(gameEventsData[0].values.map(function(d){ return d.x})).values();
                //NOT REQUIRED//unique_values.forEach(function(d){
                //NOT REQUIRED//    gameEventsData.forEach(function(series){
                //NOT REQUIRED//        var count = series.values.filter(function(dd){ return dd.x == d}).length;
                //NOT REQUIRED//        series.values.filter(function(dd){ return dd.x == d})
                //NOT REQUIRED//            .forEach(function(dd, i){
                //NOT REQUIRED//                // Add count and offset to place the flag easily in case of multiple flags
                //NOT REQUIRED//                dd.count = count;
                //NOT REQUIRED//                dd.offset = i;
                //NOT REQUIRED//            });
                //NOT REQUIRED//    });
                //NOT REQUIRED//});

                //OLD//gameEventsData.forEach(function(series){
                //OLD//    // Keeping the total number of events at that location so that mutliple can be placed easily
                //OLD//    var count = series.values.length;
                //OLD//    var temp = series.values.map(function(point){
                //OLD//        return point.events.map(function(game_event, i){
                //OLD//            return {
                //OLD//                x: point.x,
                //OLD//                y: point.y,
                //OLD//                label: game_event,
                //OLD//                count: count,
                //OLD//                offset: i
                //OLD//            }
                //OLD//        });
                //OLD//    });
                //OLD//    series.values = d3.merge(temp);
                //OLD//});
                // Create the entire events data
                eventsData = adEventsData.concat(gameEventsData);
                //NEW//eventsData = gameEventsData;

                // Extract the segments data
                // TODO Making modifications but not sure if period event is the start of the event of end of the event?? ASK QUESTION
                // I am assuming start
                segmentData = Object.keys(response)
                                .filter(function(key){ return key === 'period'})
                                .map(function(key){
                                    return {
                                        key: key,
                                        segment: true,
                                        values: response[key].map(function(point){
                                            return {
                                                x: new Date(point[0]*1000),
                                                label: point[1]
                                            }
                                        })
                                    }
                                });

                // Get the abs data for cumulative
                $.ajax({
                    url: urls[1],
                    dataType: "jsonp",
                    success: function(response){
                        // Extract the timeline data
                        cumulativeTimelineData = Object.keys(response)
                                        .filter(function(key){ return key !== 'allevent' && key !== 'period'})
                                        .map(function(key, i){
                                            return{
                                                key: key,
                                                cumulative: true,
                                                values: response[key].map(function(point){
                                                    return {
                                                        x: new Date(point[0]*1000),
                                                        y: point[1]
                                                    }
                                                })
                                            }
                                        });

                        $.ajax({
                            url: urls[2],
                            dataType: "jsonp",
                            success: function(response){
                                // Extract the sentiment data
                                sentimentData = Object.keys(response)
                                                .map(function(key){
                                                    return{
                                                        key: key,
                                                        sentiment: true,
                                                        values: response[key].map(function(point){
                                                            return {
                                                                x: new Date(point[0]*1000),
                                                                y: point[1]
                                                            }
                                                        })
                                                    }
                                                });
                                var sortOrder = timelineData.map(function(series){ return series.key});
                                // sort sentiment based on timeline order
                                sentimentData = sentimentData.sort(function(series1, series2){ return sortOrder.indexOf(series1.key) > sortOrder.indexOf(series2.key)});

                                // Create the entire data used to create the chart
                                //plotData = timelineData.concat(sentimentData, eventsData, segmentData);
                                plotData = timelineData.concat(sentimentData, eventsData, segmentData, cumulativeTimelineData);

                                // Create the chart once all the data is loaded and pre-processed
                                nv.addGraph(function() {
                                  var chart = nv.models.timelineAndSentimentChart();
                                
                                  chart.yAxis
                                      .tickFormat(d3.format('.2f'));
                                  chart.y2Axis
                                      .tickFormat(d3.format('f'));
                                
                                  chart.controlCB(function(){
                                      alert('This is the control function in html');
                                  });

                                  // Controls buttons    
                                  //chart.showControls(true);
                                  chart.controlsData([
                                    //{key:'Count1', disabled:false, onClick: function(){alert('In count1');}}, 
                                    {key:'Count1', disabled:false}, 
                                    {key:'Percent1', disabled:true, onClick: function(){alert('In percent1');}}]
                                  );
                                
                                  //TEST//chart.margin({top: 60, right: 80, bottom: 80, left: 80});
                                  chart.chartTitle(myBrand+" Performance during Superbowl XLVIII")
                                        .chartTitleStyle("text-anchor:middle;font-family:Helvetica;color:#333333;font-size:24px");
                                
                                chart.yAxisLabel("Engagement Share (%)")
                                        .yAxisLabelStyle("text-anchor:middle;font-family:Helvetica;color:#333333;font-size:18px")
                                      .y4AxisLabel("Total Tweets about "+myBrand)
                                      .y3AxisLabel("+ve sentiment")
                                      .y3AxisLabelStyle("text-anchor:middle;font-family:Helvetica;color:#333333;font-size:18px")
                                      //.color([d3.scale.category20().range()[0], d3.scale.category20().range()[2], d3.scale.category20().range()[6], d3.scale.category20().range()[12]])
                                      .color(["#663399", "#dbf6ef", "#FF0F00", "#FF9E01", "#04D215", "#0D52D1", "#8A0CCF", "#999999"])
                                      ;


                                  // Enable/Disable any of the extra features added. Set the extentThreshold based on the bin-width 
                                  chart.extentThreshold(58570*2);
                                  chart.plotCumulativeArea(true);
                                  //chart.plotMarkers(true);
                                  chart.plotSegments(true);

                                  // Create the chart here 
                                  d3.select('#chart svg')
                                      .datum(plotData)
                                      .call(chart);
                                
                                  nv.utils.windowResize(chart.update);
                                
                                  return chart;
                                });
                            }
                        });
                    }
                });

            }
        });
    });

</script>
